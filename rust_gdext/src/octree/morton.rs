use super::BoundingBox;
use super::visualize::VisualizeOctree;
use crate::octree::GravityData;
use derivative::Derivative;
use glam::{U64Vec3, Vec3A};
use rayon::prelude::*;
use std::fmt::Debug;
use std::{num::NonZeroUsize, ops::Range};

/// A Morton code is a 64-bit integer that encodes the position of a point in 3D space.
/// It is used to efficiently index and retrieve points in a spatial data structure.
/// The Morton code is generated by interleaving the bits of the x, y, and z coordinates.
/// This allows for efficient spatial locality and range queries.
///
/// The Morton code is used to sort the points in the octree, which allows for efficient
/// construction of the octree structure.
pub type MortonCode = u64;

// Max depth for u64 Morton code in 3D
pub const MAX_DEPTH: u32 = (size_of::<MortonCode>() as u32 * 8) / 3;

/// Calculates the 3D Morton code for a point within given bounds.
pub fn encode(point: Vec3A, bounds: &BoundingBox) -> MortonCode {
    let grid_resolution = (1u64 << MAX_DEPTH) as f32;
    // Maximum integer coordinate value for MAX_DEPTH bits
    let max_coord_val = (1u64 << MAX_DEPTH) - 1;

    // Calculate the minimum corner of the bounding box
    let min_corner = bounds.center - Vec3A::splat(bounds.half_width);
    // Calculate the total width of the bounding box (must be > 0)
    let width = 2.0 * bounds.half_width;

    // Handle zero-width boxes (e.g., all points coincident) - Morton code is trivial
    // Use epsilon for float comparison
    if width <= 1e-9 {
        return 0;
    }
    let scale = 1.0 / width;

    // Calculate point's position relative to the min corner, scaled to [0, 1]
    let normalized = (point - min_corner) * scale;

    // Scale to integer grid coordinates [0, 2^depth - 1]
    let grid_coords = normalized * grid_resolution;

    // Clamp coordinates before casting to avoid issues with points exactly on max boundary
    // or slight floating point inaccuracies pushing them over.
    // Cast to u64 first for range, clamp, then cast to u32 for spread_bits.
    let grid = grid_coords
        .max(const { Vec3A::splat(0.0) })
        .as_u64vec3()
        .min(U64Vec3::splat(max_coord_val))
        .as_uvec3();

    let spread = grid.to_array().map(spread_bits);

    // Interleave Z(msb)..X(lsb): Z shifted by 2, Y shifted by 1
    (spread[2] << 2) | (spread[1] << 1) | spread[0]
}

/// A temporary struct to hold Morton code and index during sorting.
#[derive(Derivative, Clone, Copy)]
#[derivative(PartialEq, PartialOrd, Eq, Ord)]
pub struct MortonEncodedItem<T> {
    pub morton_code: MortonCode,

    #[derivative(PartialEq = "ignore", PartialOrd = "ignore", Ord = "ignore")]
    pub item: T,
}

impl<T> MortonEncodedItem<T> {
    /// Determines the child octant index (0-7) for a Morton code relative to its parent at 'depth'.
    #[inline]
    const fn get_octant_index_at_depth(&self, depth: u32) -> u8 {
        // Shift the code so the bits for the desired depth are the least significant
        // Each depth uses 3 bits (z, y, x)
        // The bits for depth 'depth' start at bit position 3 * (max_tree_depth - 1 - depth)
        // depth = 0 => shift = 3 * 20 = 60
        // depth = 1 => shift = 3 * 19 = 57
        // ...
        // depth = 20 => shift = 3 * 0 = 0

        let shift_amount = 3 * (MAX_DEPTH - 1 - depth);
        // Extract the 3 relevant bits (z, y, x for that depth)
        ((self.morton_code >> shift_amount) & 0b111) as u8
    }

    #[inline]
    pub const fn common_prefix_length(&self, other: &Self) -> u32 {
        // Calculate the length of the longest common prefix (LCP) between two Morton codes.
        // This is done by XORing the codes and counting leading zeros.
        let xored = self.morton_code ^ other.morton_code;
        if xored == 0 {
            const { MAX_DEPTH * 3 }
        } else {
            xored.leading_zeros()
        }
    }
}

impl<T: Debug> Debug for MortonEncodedItem<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MortonEncodedItem")
            .field("code", &format!("{:b}", self.morton_code))
            .field("body_index", &self.item)
            .finish()
    }
}

/// Spreads the lower `MAX_DEPTH` bits of `v` by inserting two zero bits between each.
/// Example (3 bits): 101 -> 001 000 001
pub fn spread_bits(v: u32) -> u64 {
    // Mask to ensure we only consider bits relevant to max depth
    let mask = (1u64 << MAX_DEPTH) - 1;
    let mut x = (v as u64) & mask;
    // Using "magic bit" interleaving approach
    // https://stackoverflow.com/questions/18529057/produce-interleaving-bit-patterns-morton-keys-for-32-bit-64-bit-and-128bit
    x &= 0x1fffff;
    x = (x | x << 32) & 0x1f00000000ffff;
    x = (x | x << 16) & 0x1f0000ff0000ff;
    x = (x | x << 8) & 0x100f00f00f00f00f;
    x = (x | x << 4) & 0x10c30c30c30c30c3;
    x = (x | x << 2) & 0x1249249249249249;
    x
}

/// Calculates the octree depth corresponding to a shared Morton prefix length.
/// Assumes 64-bit code, 3 bits per depth. Max useful prefix = 63 (depth 21).
#[inline]
pub const fn split_depth_from_lcp(lcp_length: u32) -> u32 {
    // The depth where the split occurs is determined by the first differing bit triplet.
    // If LCP is 63 (max), they share the deepest prefix, depth is effectively MAX_DEPTH.
    // If LCP is 60, 61, 62, they differ in the last triplet, split is at depth 20.
    // If LCP is 0, 1, 2, they differ in the first triplet, split is at depth 0.
    lcp_length / 3 // Integer division gives the depth of the common parent
}

#[derive(Debug, Clone, Default)]
pub struct Node {
    /// The bounding box of the node.
    ///
    /// This is a 3D box defined by its center and half-width.
    /// The half-width is the maximum distance from the center to any corner of the box.
    pub bounds: BoundingBox,

    pub children: [Option<NonZeroUsize>; 8],
    pub body_range: Range<usize>,
    pub depth: u32,

    /// The data associated with this node.
    ///
    /// This can be either internal or leaf data.
    pub data: GravityData,
}

/// The resulting octree structure.
/// Might evolve, but starts with nodes and bounds.
#[derive(Debug, Default)]
pub struct MortonOctree<'a> {
    /// Arena storing the explicit node hierarchy built from the sorted list.
    /// Note: The 'Node' struct might need modification from the top-down
    /// version (e.g., explicit child pointers instead of n_subtree_nodes).
    // pub nodes: Vec<Node>,
    pub nodes: Vec<Node>,

    /// The overall bounds of the octree root.
    pub bounds: BoundingBox,

    /// Reference to the original data used to build the octree.
    pub data_ref: &'a [GravityData],
}

impl VisualizeOctree for MortonOctree<'_> {
    fn get_bounds_and_depths(&self) -> Vec<(BoundingBox, u32)> {
        self.nodes
            .iter()
            .map(|node| (node.bounds, node.depth))
            .collect()
    }
}

impl<'a> MortonOctree<'a> {
    /// Main function to build the octree from body data using Morton codes.
    pub fn new(bodies: &'a [GravityData]) -> Self {
        if bodies.is_empty() {
            return Default::default();
        }

        // --- Stage 1: Calculate Morton Codes ---
        let bounds = BoundingBox::containing_gravity_data(bodies);

        let encode_item = |(index, data): (usize, &GravityData)| {
            // Pass the calculated cubic bounds to the encode function
            let code = encode(data.center_of_mass, &bounds);
            MortonEncodedItem {
                morton_code: code,
                item: index,
            }
        };

        // Use parallel iteration for large datasets, otherwise sequential
        // The value was chosen based on benchmarks
        let mut encoded_bodies: Vec<MortonEncodedItem<_>> = if bodies.len() >= 3000 {
            bodies
                .into_par_iter()
                .enumerate()
                .map(encode_item)
                .collect()
        } else {
            bodies.iter().enumerate().map(encode_item).collect()
        };

        // --- Stage 2: Sort by Morton Code ---
        // Parallel sort is not slower than sequential even for small datasets (benchmarked)
        encoded_bodies.par_sort_unstable();

        // --- Stage 3: Build Explicit Tree Hierarchy ---
        let mut nodes = Vec::with_capacity(encoded_bodies.len() * 2 + 128);
        let _root_index = Self::build_recursive(
            &mut nodes,
            &encoded_bodies, // Pass immutable slice
            bodies,
            0..encoded_bodies.len(), // Range of bodies in the current node
            &bounds,                 // current node bounds
            0,                       // current depth
        );

        MortonOctree {
            nodes,
            bounds,
            data_ref: bodies,
        }
    }

    fn build_recursive(
        node_arena: &mut Vec<Node>,
        sorted_bodies: &[MortonEncodedItem<usize>],
        data_ref: &[GravityData],
        body_range: Range<usize>,
        node_bounds: &BoundingBox,
        current_depth: u32,
    ) -> usize {
        let count = body_range.end - body_range.start;
        if count == 0 {
            // This shouldn't happen for valid child calls, but handle defensively
            // Or perhaps return an Option<usize> instead. For simplicity, create dummy.
            let node_index = node_arena.len();
            node_arena.push(Node {
                body_range,
                children: [None; 8],
                bounds: *node_bounds,
                data: Default::default(),
                depth: current_depth,
            });
            return node_index; // Might need better empty node handling
        }

        let current_node_index = node_arena.len();

        // --- Leaf Node ---
        if count == 1 || current_depth == MAX_DEPTH {
            let data =
                GravityData::merge(body_range.clone().map(|i| &data_ref[sorted_bodies[i].item]));

            node_arena.push(Node {
                body_range,
                children: [None; 8],
                bounds: *node_bounds,
                data,
                depth: current_depth,
            });

            return current_node_index;
        }

        // --- Internal Node ---
        // Add a placeholder node first, we'll fill it later after children are processed
        node_arena.push(Node {
            body_range: body_range.clone(),
            children: [None; 8],  // Placeholder
            bounds: *node_bounds, // Placeholder
            ..Default::default()  // Placeholder
        });

        // --- Partition bodies into 8 children based on Morton codes ---
        // Since bodies are sorted by Morton code, all bodies belonging to a specific
        // child octant at this depth will form a contiguous sub-slice.
        // We need to find the split points.

        // Stores start index for each child + end of last
        let mut split_indices = [body_range.start; 9];
        split_indices[8] = body_range.end; // End of the range for child 7

        // Find the start index for children 1 through 7
        let mut current_search_start = body_range.start;
        for octant in 0..7 {
            // Find divisions between octant N and N+1
            let split_point = Self::find_octant_split(
                sorted_bodies,
                current_search_start..(body_range.end),
                octant, // We are looking for the first particle NOT in this octant or lower
                current_depth,
            );
            split_indices[octant as usize + 1] = split_point;
            current_search_start = split_point; // Start next search from here
        }

        // --- Recursively build children and gather properties ---
        let mut child_node_indices = [None; 8];
        let mut total_mass_acc = 0.0;
        let mut weighted_pos_sum_acc = Vec3A::ZERO;

        // Potential parallelization point using rayon::scope or join
        for (octant, child_range) in split_indices
            .array_windows::<2>()
            .map(|[a, b]| *a..*b)
            .enumerate()
        {
            if !child_range.is_empty() {
                let child_bounds = node_bounds.get_octant_bounds_morton(octant as u8);
                let child_node_index = Self::build_recursive(
                    node_arena,
                    sorted_bodies,
                    data_ref,
                    child_range,
                    &child_bounds,
                    current_depth + 1,
                );
                child_node_indices[octant] = NonZeroUsize::new(child_node_index);

                // Accumulate mass and weighted position from the child
                // Read the properties from the newly created child node
                let child_node = &node_arena[child_node_index]; // Read back the child node
                total_mass_acc += child_node.data.mass;
                weighted_pos_sum_acc += child_node.data.weighted_center();
            } else {
                child_node_indices[octant] = None;
            }
        }

        // --- Finalize the current internal node ---
        let center_of_mass = if total_mass_acc > 0.0 {
            weighted_pos_sum_acc / total_mass_acc
        } else {
            node_bounds.center // Geometric center if mass is zero
        };

        // Update the placeholder node that was added earlier
        let current_node = &mut node_arena[current_node_index];
        *current_node = Node {
            body_range,
            bounds: *node_bounds,
            children: child_node_indices,
            data: GravityData {
                center_of_mass,
                mass: total_mass_acc,
            },
            ..*current_node
        };

        current_node_index
    }

    // Helper function to find the first particle index in [range_start, range_end)
    // that does *not* belong to `target_octant` or lower octants at the given depth.
    // Uses binary search since the input slice `sorted_bodies` is sorted by Morton code.
    fn find_octant_split(
        sorted_bodies: &[MortonEncodedItem<usize>],
        range: Range<usize>,
        target_octant: u8, // Find first particle with octant > target_octant
        depth: u32,
    ) -> usize {
        let pred = |item: &MortonEncodedItem<usize>| {
            item.get_octant_index_at_depth(depth) <= target_octant
        };

        range.start + sorted_bodies[range].partition_point(pred)
    }
}
