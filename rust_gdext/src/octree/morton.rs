use std::{
    array,
    num::NonZeroUsize,
    ops::{Range, RangeBounds},
};

use derivative::Derivative;
use glam::{U64Vec3, Vec3A};
use godot::obj::bounds;
use itertools::Itertools;
use rayon::prelude::*;

use super::{BoundingBox, GravityData};

use std::fmt::Debug;

use super::*;

/// A Morton code is a 64-bit integer that encodes the position of a point in 3D space.
/// It is used to efficiently index and retrieve points in a spatial data structure.
/// The Morton code is generated by interleaving the bits of the x, y, and z coordinates.
/// This allows for efficient spatial locality and range queries.
///
/// The Morton code is used to sort the points in the octree, which allows for efficient
/// construction of the octree structure.
pub type MortonCode = u64;

// Max depth for u64 Morton code in 3D
pub const MAX_DEPTH: u32 = (size_of::<MortonCode>() as u32 * 8) / 3;

/// Calculates the 3D Morton code for a point within given bounds.
pub fn encode(point: Vec3A, bounds: &BoundingBox) -> MortonCode {
    let grid_resolution = (1u64 << MAX_DEPTH) as f32;
    // Maximum integer coordinate value for MAX_DEPTH bits
    let max_coord_val = (1u64 << MAX_DEPTH) - 1;

    // Calculate the minimum corner of the bounding box
    let min_corner = bounds.center - Vec3A::splat(bounds.half_width);
    // Calculate the total width of the bounding box (must be > 0)
    let width = 2.0 * bounds.half_width;

    // Handle zero-width boxes (e.g., all points coincident) - Morton code is trivial
    // Use epsilon for float comparison
    if width <= 1e-9 {
        return 0;
    }
    let scale = 1.0 / width;

    // Calculate point's position relative to the min corner, scaled to [0, 1]
    let normalized = (point - min_corner) * scale;

    // Scale to integer grid coordinates [0, 2^depth - 1]
    let grid_coords = normalized * grid_resolution;

    // Clamp coordinates before casting to avoid issues with points exactly on max boundary
    // or slight floating point inaccuracies pushing them over.
    // Cast to u64 first for range, clamp, then cast to u32 for spread_bits.
    let grid = grid_coords
        .max(const { Vec3A::splat(0.0) })
        .as_u64vec3()
        .min(U64Vec3::splat(max_coord_val))
        .as_uvec3();

    let spread = grid.to_array().map(spread_bits);

    // Interleave Z(msb)..X(lsb): Z shifted by 2, Y shifted by 1
    (spread[2] << 2) | (spread[1] << 1) | spread[0]
}

/// A temporary struct to hold Morton code and index during sorting.
#[derive(Derivative, Clone, Copy)]
#[derivative(PartialEq, PartialOrd, Eq, Ord)]
pub struct MortonEncodedItem {
    #[derivative(Debug(format_with = "format_morton_code"))]
    pub code: MortonCode,

    #[derivative(PartialEq = "ignore", PartialOrd = "ignore", Ord = "ignore")]
    pub body_index: usize,
}

impl MortonEncodedItem {
    /// Determines the child octant index (0-7) for a Morton code relative to its parent at 'level'.
    #[inline]
    const fn get_octant_index_at_level(&self, level: u32) -> usize {
        // Level 0 -> uses bits 60-62. Level 1 -> bits 57-59, etc.
        // Max prefix bits used = MAX_DEPTH * 3 = 63.
        // Shift needed to bring the relevant 3 bits to the LSB position.
        let shift = (MAX_DEPTH * 3) - 3 * (level + 1);
        ((self.code >> shift) & 0b111) as usize
    }
}

impl Debug for MortonEncodedItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MortonEncodedItem")
            .field("code", &format!("{:b}", self.code))
            .field("body_index", &self.body_index)
            .finish()
    }
}

/// Spreads the lower `MAX_DEPTH` bits of `v` by inserting two zero bits between each.
/// Example (3 bits): 101 -> 001 000 001
pub fn spread_bits(v: u32) -> u64 {
    // Mask to ensure we only consider bits relevant to max depth
    let mask = (1u64 << MAX_DEPTH) - 1;
    let mut x = (v as u64) & mask;
    // Using "magic bit" interleaving approach
    // https://stackoverflow.com/questions/18529057/produce-interleaving-bit-patterns-morton-keys-for-32-bit-64-bit-and-128bit
    x &= 0x1fffff;
    x = (x | x << 32) & 0x1f00000000ffff;
    x = (x | x << 16) & 0x1f0000ff0000ff;
    x = (x | x << 8) & 0x100f00f00f00f00f;
    x = (x | x << 4) & 0x10c30c30c30c30c3;
    x = (x | x << 2) & 0x1249249249249249;
    x
}

/// Calculates the octree level corresponding to a shared Morton prefix length.
/// Assumes 64-bit code, 3 bits per level. Max useful prefix = 63 (level 21).
#[inline]
const fn split_level_from_lcp(lcp_length: u32) -> u32 {
    // The level where the split occurs is determined by the first differing bit triplet.
    // If LCP is 63 (max), they share the deepest prefix, level is effectively MAX_DEPTH.
    // If LCP is 60, 61, 62, they differ in the last triplet, split is at level 20.
    // If LCP is 0, 1, 2, they differ in the first triplet, split is at level 0.
    lcp_length / 3 // Integer division gives the level of the common parent
}

#[test]
fn hej() {
    let points: Vec<_> = (0..=3)
        .cartesian_product(0..=3)
        .cartesian_product(0..=3)
        .map(|((x, y), z)| Vec3A::new(x as f32, y as f32, z as f32))
        .collect_vec();

    let gds: Vec<_> = points
        .iter()
        .map(|p| GravityData {
            center_of_mass: *p,
            ..Default::default()
        })
        .collect();

    let octree = MortonOctree::build(&gds);
    dbg!(&octree);
    dbg!(octree.get_bounds_and_depths());
}

#[derive(Debug, Default, Clone)]
pub struct Node {
    /// The bounding box of the node.
    ///
    /// This is a 3D box defined by its center and half-width.
    /// The half-width is the maximum distance from the center to any corner of the box.
    pub bounds: BoundingBox,

    pub children: [Option<NonZeroUsize>; 8],
    pub body_range: Range<usize>,
    pub level: u32,

    /// The data associated with this node.
    ///
    /// This can be either internal or leaf data.
    pub data: GravityData,
}

impl Node {
    // Helper to create a root node
    fn root(n: usize, global_bounds: BoundingBox) -> Self {
        Self {
            bounds: global_bounds,
            children: [None; 8],
            body_range: 0..n,
            level: 0,
            data: Default::default(),
        }
    }
    // Helper to create an internal node during construction
    fn internal(level: u32, bounds: BoundingBox, range_start: usize) -> Self {
        Self {
            bounds,
            children: [None; 8],                 // Initialize empty children
            body_range: range_start..usize::MAX, // End will be determined later
            level,
            data: Default::default(),
        }
    }
}

/// The resulting octree structure.
/// Might evolve, but starts with nodes and bounds.
#[derive(Debug, Default)]
pub struct MortonOctree {
    /// Arena storing the explicit node hierarchy built from the sorted list.
    /// Note: The 'Node' struct might need modification from the top-down
    /// version (e.g., explicit child pointers instead of n_subtree_nodes).
    pub nodes: Vec<Node>,

    /// The overall bounds of the octree root.
    pub bounds: BoundingBox,
}

impl VisualizeOctree for MortonOctree {
    fn get_bounds_and_depths(&self) -> Vec<(BoundingBox, u32)> {
        self.nodes
            .iter()
            .map(|node| (node.bounds, node.level))
            .collect()
    }
}

impl MortonOctree {
    /// Main function to build the octree from body data using Morton codes.
    pub fn build(bodies: &[GravityData]) -> Self {
        if bodies.is_empty() {
            return Default::default();
        }

        // --- Stage 1: Calculate Morton Codes ---
        let bounds = BoundingBox::containing_gravity_data(bodies);

        let encode_item = |(index, body): (usize, &GravityData)| {
            // Pass the calculated cubic bounds to the encode function
            let code = morton::encode(body.center_of_mass, &bounds);
            MortonEncodedItem {
                code,
                body_index: index,
            }
        };

        // Use parallel iteration for large datasets, otherwise sequential
        // The value was chosen based on benchmarks
        let mut encoded_bodies: Vec<MortonEncodedItem> = if bodies.len() >= 3000 {
            bodies.par_iter().enumerate().map(encode_item).collect()
        } else {
            bodies.iter().enumerate().map(encode_item).collect()
        };

        // --- Stage 2: Sort by Morton Code ---
        // Parallel sort is not slower than sequential even for small datasets (benchmarked)
        encoded_bodies.par_sort_unstable();

        // --- Stage 3: Build Explicit Tree Hierarchy ---
        let mut nodes = Self::construct_tree_hierarchy(&encoded_bodies, bounds);

        // --- Stage 4: Calculate Aggregate Node Properties ---
        Self::calculate_node_aggregates(&mut nodes, &encoded_bodies, bodies);

        MortonOctree { nodes, bounds }
    }

    /// Constructs the tree hierarchy from the sorted Morton codes.
    ///
    /// ## Input Invariant:
    ///
    /// The Morton codes are sorted in ascending order.
    fn construct_tree_hierarchy(
        sorted_encoded_bodies: &[MortonEncodedItem],
        global_bounds: BoundingBox,
    ) -> Vec<Node> {
        let n = sorted_encoded_bodies.len();
        if n == 0 {
            return Vec::new();
        }

        // --- Node Arena ---
        let mut nodes = Vec::<Node>::with_capacity(n * 2);

        // --- Calculate LCP Array ---
        // LCP[i] = common prefix length between code[i] and code[i+1]
        let lcps: Vec<u32> = sorted_encoded_bodies
            .windows(2) // ! BENCHMARK PAR_WINDOWS
            .map(|codes| {
                let code1 = codes[0].code;
                let code2 = codes[1].code;
                let xored = code1 ^ code2;
                // Handle identical codes explicitly for max LCP length
                if xored == 0 {
                    const { MAX_DEPTH * 3 }
                } else {
                    xored.leading_zeros()
                }
            })
            .collect();

        // --- Initialize Root & Stack ---
        nodes.push(Node::root(n, global_bounds));

        // Stack holds indices of nodes whose children are currently being processed
        let mut parent_stack = vec![0usize]; // Start with root index

        // --- Iterate through split points ---
        for (i, lcp_length) in lcps.into_iter().enumerate() {
            let split_level = split_level_from_lcp(lcp_length);

            // --- Pop completed nodes from stack ---
            // Pop nodes deeper than the split level, finalizing their range
            while let Some(finished_node_idx) =
                parent_stack.pop_if(|parent| nodes[*parent].level > split_level)
            {
                nodes[finished_node_idx].body_range.end = i + 1;
            }

            // --- Ensure parent at split_level exists (create intermediates if needed) ---
            // This handles cases where the LCP jump is large (e.g., LCP drops significantly)
            let mut curr_parent_idx = *parent_stack.last().unwrap();
            while nodes[curr_parent_idx].level < split_level {
                let parent_level = nodes[curr_parent_idx].level;
                // Determine which octant body 'i+1' falls into relative to this ancestor
                let octant = sorted_encoded_bodies[i + 1].get_octant_index_at_level(parent_level);

                // Create the intermediate node
                let intermediate_level = parent_level + 1;
                let intermediate_bounds = nodes[curr_parent_idx]
                    .bounds
                    .get_octant_bounds_morton(octant);

                let new_idx = nodes.len();

                nodes.push(Node::internal(
                    intermediate_level,
                    intermediate_bounds,
                    i + 1,
                ));

                // Link intermediate node as child of current parent
                nodes[curr_parent_idx].children[octant] = NonZeroUsize::new(new_idx);
                parent_stack.push(new_idx);

                // ADD THIS: Check the link immediately after making it
                if curr_parent_idx == 1 && octant == 4 {
                    // Check the specific case from i=3 trace
                    dbg!(
                        "Link Check (i=3):",
                        curr_parent_idx,
                        octant,
                        new_idx,
                        &nodes[curr_parent_idx].children
                    );
                }

                curr_parent_idx = new_idx;
            }

            // --- Create/link node for body i+1 branch ---
            let parent_idx = *parent_stack.last().unwrap(); // Parent is now at split_level
            let new_node_level = split_level + 1;
            let octant = sorted_encoded_bodies[i + 1].get_octant_index_at_level(split_level);
            let new_bounds = nodes[parent_idx].bounds.get_octant_bounds_morton(octant);
            let new_idx = nodes.len();

            // --- Debugging Point ---
            let next_body_code = sorted_encoded_bodies[i + 1].code;
            let calculated_octant =
                sorted_encoded_bodies[i + 1].get_octant_index_at_level(split_level);
            let calculated_bounds = nodes[parent_idx]
                .bounds
                .get_octant_bounds_morton(calculated_octant);
            let new_node_idx = nodes.len(); // Index where the new node *will be* placed

            dbg!(
                i, // Index of the split point being processed
                lcp_length,
                split_level,
                parent_idx,              // Index of the parent node determined
                nodes[parent_idx].level, // Level of the parent
                next_body_code,          // Code of the body starting the new branch
                calculated_octant,       // The octant this branch belongs to relative to parent
                new_node_level,          // Expected level of the new node
                calculated_bounds,       // Bounds calculated for the new node
                new_node_idx             // Index the new node will have in the arena
            );

            // Add the new node to the arena
            nodes.push(Node::internal(new_node_level, new_bounds, i + 1));

            // Link it to the parent
            nodes[parent_idx].children[octant] = NonZeroUsize::new(new_idx);

            // Push the new node onto the stack as it's now the active branch
            parent_stack.push(new_idx);
        }

        // --- Finalize ranges for nodes remaining on stack ---
        // After the loop, the stack contains the path from the root
        // to the node containing the last body
        while let Some(idx) = parent_stack.pop() {
            nodes[idx].body_range.end = n;
        }

        nodes
    }

    // --- Placeholder for aggregate calculation ---
    fn calculate_node_aggregates(
        nodes: &mut Vec<Node>,
        sorted_encoded_bodies: &[MortonEncodedItem],
        original_bodies: &[GravityData],
    ) {
        eprintln!("WARNING: calculate_node_aggregates not implemented!");
        // TODO: Implement aggregate calculation
    }
}
